package com.mooky.blog.domain.blog;

import java.util.Optional;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;

import com.mooky.blog.domain.blog.dto.BlogDetailsDto;
import com.mooky.blog.domain.blog.dto.BlogWriteDto;
import com.mooky.blog.domain.blog.entity.Blog;
import com.mooky.blog.domain.blog.repository.BlogRepository;
import com.mooky.pet_diary.global.exception.ApiException.NotFoundException;

import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class BlogService {

    private final BlogRepository blogRepository;
    private final EntityManager entityManager;

    /*
    * TODO article
    * Saving Blog Entity, which has BlogCreaterEntity as a joined table
    * problems :
    * (1) current_timestamp() default value generated by database - returned as
    * null
    * (2) Using JPA's save method does not return BlogCreaterEntity = null
    * 
    * reason:
    * (1) save() operation primarily focuses on persisting the entity's state so
    * JPA might not automatically retrieve it after saving
    * (2) BlogEntity's BlogCreaterEntity value was null to begin with, so JPA's
    * persistence context did not automatically synchronize and join tables
    * 
    * solution:
    * (1) @CreationTimestamp annotation
    * (2) use entityManager to flush and refresh the entity
    * - (a) private final EntityManager entityManager;
    * --> error : jakarta.persistence.TransactionRequiredException: No
    * EntityManager with actual transaction available for current thread
    * 
    * --> what is EntityManager?
    * - implements the programming interfaces and lifecycle rules defined by JPA
    * - can access Persistence Context
    * (1) Container-Manager EntityManager uses @PersistenceContext
    * = container creates the EntityManager from EntityManagerFactory
    * = container is in charge of beginning the transaction, rolling back or
    * committing
    * = managed by the container so no need for manual cleanups
    * 
    * (2) Application-Managed EntityMa
    * - EntityManagerFactory emf =
    * Persistence.createEntityManagerFactory("com.mooky.blog");
    * = manually creating, so need to maually close
    * 
    * - EntityManager instances are NOT thread-safe, but container ensures that each EntityManager is confined to one thread
    * by injecting a special proxy (SharedEntityManagerCreator) which reuses the existing EntityManager or creates a new one
    * 
    * - (b) Transactional
    * --> error : Could not generate CGLIB subclass of class
    * com.mooky.blog.domain.blog.BlogService: Common causes of this problem include
    * using a final class or a non-visible class
    * 
    * - (c) public Entitymanager entityManager;
    * --> error : this.entityManager" is null
    * 
    * - (d) @PersistenceContext or @Autowired 
    * 
    * Hibernate: insert into blog (author_id,content,created_by,modified_at,title)
    * values (?,?,?,?,?)
    * Hibernate: select
    * be1_0.blog_id,a1_0.user_id,a1_0.username,be1_0.author_id,be1_0.content,be1_0.
    * created_at,be1_0.created_by,be1_0.modified_at,be1_0.title from blog be1_0
    * left join user a1_0 on a1_0.user_id=be1_0.author_id where be1_0.blog_id=?
    * 
    * conclusion: you can either
    * (1) save and findById to retrieve the latest and joined entity
    * (2) or use entityManager to refresh the entity
    */

    public BlogDetailsDto findBlogUsingNativeQuery(Long blogId) {
        BlogDetailsDto blogDetails = this.blogRepository.findBlogDetailsWithNativeQuery(blogId).orElseThrow(
                () -> new NotFoundException("blog_not_found", "없는 블로그입니다", String.valueOf(blogId), null));
        return blogDetails;
    }

    public BlogDetailsDto findBlogAndReturnBlogDetails(Long blogId) {
        Blog blogEntity = this.blogRepository.findById(blogId)
                .orElseThrow(() -> new NotFoundException("blog_not_found", "없는 블로그입니다", String.valueOf(blogId), null));
        return new BlogDetailsDto(blogEntity);
    }

    @Transactional
    public BlogDetailsDto saveBlogAndReturnBlogDetails(BlogWriteDto blogReq) {
        // TODO mapstruct 
        try {
            Blog savedBlog = this.blogRepository.save(new Blog(blogReq));
            this.entityManager.refresh(savedBlog);
            return new BlogDetailsDto(savedBlog);
        } catch (DataIntegrityViolationException ex) {
            throw new NotFoundException("user_not_found", "없는 사용자입니다.", blogReq.getUserId().toString(), null);
        }
    }
    
    public BlogDetailsDto editBlogAndReturnBlogDetails(Long blogId, BlogWriteDto blogReq) {
        int numOfEditedRows = this.blogRepository.editBlog(blogId, blogReq.getTitle(), blogReq.getContent());
        if (numOfEditedRows == 0) {
            throw new NotFoundException("blog_not_found", "없는 블로그입니다", String.valueOf(blogId), null);
        }
        Optional<Blog> blogEntity = this.blogRepository.findById(blogId);
        return new BlogDetailsDto(blogEntity.get());
    }

}
