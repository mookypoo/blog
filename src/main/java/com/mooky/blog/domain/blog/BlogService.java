package com.mooky.blog.domain.blog;

import java.util.Optional;

import org.springframework.stereotype.Service;

import com.mooky.blog.domain.blog.entity.BlogEntity;
import com.mooky.blog.domain.blog.repository.BlogRepository;
import com.mooky.blog.domain.blog.vo.BlogDetails;
import com.mooky.blog.domain.blog.vo.BlogReq;
import com.mooky.blog.global.exception.ApiException.NotFoundException;

import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@AllArgsConstructor
public class BlogService {

  private BlogRepository blogRepository;

  private EntityManager entityManager;

  /*
   * TODO article
   * Saving Blog Entity, which has BlogCreaterEntity as a joined table
   * problems :
   * (1) current_timestamp() default value generated by database - returned as
   * null
   * (2) Using JPA's save method does not return BlogCreaterEntity = null
   * 
   * reason:
   * (1) save() operation primarily focuses on persisting the entity's state so
   * JPA might not automatically retrieve it after saving
   * (2) BlogEntity's BlogCreaterEntity value was null to begin with, so JPA's
   * persistence context did not automatically synchronize and join tables
   * 
   * solution:
   * (1) @CreationTimestamp annotation
   * (2) use entityManager to flush and refresh the entity
   * - (a) private final EntityManager entityManager;
   * --> error : jakarta.persistence.TransactionRequiredException: No
   * EntityManager with actual transaction available for current thread
   * 
   * --> what is EntityManager?
   * - implements the programming interfaces and lifecycle rules defined by JPA
   * - can access Persistence Context
   * (1) Container-Manager EntityManager uses @PersistenceContext
   * = container creates the EntityManager from EntityManagerFactory
   * = container is in charge of beginning the transaction, rolling back or
   * committing
   * = managed by the container so no need for manual cleanups
   * 
   * (2) Application-Managed EntityMa
   * - EntityManagerFactory emf =
   * Persistence.createEntityManagerFactory("com.mooky.blog");
   * = manually creating, so need to maually close
   * 
   * - EntityManager instances are NOT thread-safe, but container ensures that each EntityManager is confined to one thread
   * by injecting a special proxy (SharedEntityManagerCreator) which reuses the existing EntityManager or creates a new one
   * 
   * - (b) Transactional
   * --> error : Could not generate CGLIB subclass of class
   * com.mooky.blog.domain.blog.BlogService: Common causes of this problem include
   * using a final class or a non-visible class
   * 
   * - (c) public Entitymanager entityManager;
   * --> error : this.entityManager" is null
   * 
   * - (d) @PersistenceContext or @Autowired 
   * 
   * Hibernate: insert into blog (author_id,content,created_by,modified_at,title)
   * values (?,?,?,?,?)
   * Hibernate: select
   * be1_0.blog_id,a1_0.user_id,a1_0.username,be1_0.author_id,be1_0.content,be1_0.
   * created_at,be1_0.created_by,be1_0.modified_at,be1_0.title from blog be1_0
   * left join user a1_0 on a1_0.user_id=be1_0.author_id where be1_0.blog_id=?
   * 
   * conclusion: you can either
   * (1) save and findById to retrieve the latest and joined entity
   * (2) or use entityManager to refresh the entity
   */ 

  @Transactional
  public BlogDetails saveBlogAndReturnBlogDetails(BlogReq blogReq) {
    BlogEntity savedBlog = this.blogRepository.save(new BlogEntity(blogReq));
  
    entityManager.refresh(savedBlog);
    //BlogEntity savedBlog = this.blogRepository.saveBlog(blogReq.getUserId(), blogReq.getTitle(), blogReq.getContent());
    //log.info("saved blog author", savedBlog.getAuthor().getUsername());
    return new BlogDetails(savedBlog);
  }

  public BlogDetails findBlogAndReturnBlogDetails(Long blogId) {
    BlogEntity blogEntity = this.blogRepository.findById(blogId)
        .orElseThrow(() -> new NotFoundException("blog_not_found", "없는 블로그입니다", String.valueOf(blogId), null));
    return new BlogDetails(blogEntity);
  }
  
  public BlogDetails editBlogAndReturnBlogDetails(Long blogId, BlogReq blogReq) {
    
    int numOfEditedRows = this.blogRepository.editBlog(blogId, blogReq.getTitle(), blogReq.getContent());
    if (numOfEditedRows == 0) {
      throw new NotFoundException("blog_not_found", "없는 블로그입니다", String.valueOf(blogId), null);
    }
    Optional<BlogEntity> blogEntity = this.blogRepository.findById(blogId);
    return new BlogDetails(blogEntity.get());
  
  }

}
